---
layout: single
title: "프로젝트 회고(2)"
excerpt: "프로젝트를 진행하며 고민한 것들"

categories:
  - Retrospective

tags:
  - [Project, Retrospective]

date: 2023-02-21
published: true
---

| 프로젝트를 진행하며 고민했던 것 들..
<br>

### 1. 정해진 기한 내에 빠르게 구현하기

<br>
프로젝트 시작 직 후 기획이 한 차례 변경되기도 했고, 인원 이탈도 있었기 때문에 맡아서 개발해야 하는 양이 꽤 많았었고 시간도 넉넉하지 않았다. 물론 실력이 더 뛰어났다면 문제없이 수행할 수 있었겠지만 TypeScript와 Material_UI에 대핸 숙련도가 높지 않았기 때문에 구현에 더 많은 시간이 필요했던 것 같다.

이러한 상황을 해결하기 위해 많은 고민을 했었는데 가장 도움이 됬던건 프로젝트 컨설턴트님의 조언이었다.

컨설턴트님은 **'우선은 빠르게 동작하는 코드를 만들고 추후에 수정하고 리팩토링 하는 방식'** 을 추천해주셨는데 이 방법이 상당히 효율적이었다.

가장 먼저 구현해야 하는 기능을 세분화 하고 세분화된 기능을 빠르게 구현했다. 그런 작은 기능들이 모여서 나중에는 하나의 페이지나 서비스가 되는데 설계를 자세하게 진행한게 아니었기 때문에 버그가 나오거나 로직이 꼬이는 경우도 있었다. 하지만 이미 기능을 구현하며 코드의 흐름을 어느정도 알 수 있었기 때문에 코드를 수정하거나 새롭게 짤 때도 더 빠르게 더 나은 코드를 짤 수 있었다.

심사숙고 하여 내 기준에는 완벽한 코드를 한번 짜는 것 보다. 빠르게 코드를 짜고 그 코드를 여러번 수정하고 다시 짜보는게 어쩌면 더 나은 방법일 수 도 있다.

또한 새롭게 사용해보는 Material_UI와 TypeScript의 숙련도를 빠르게 늘릴 수 있었다.
<br><br>

### 2. 비동기 처리
<br>

구글 드라이브와 유사한 기능을 구현할 때 비동기 처리에 대한 고민이 필요했다.

기본적인 코드의 흐름은 이렇다. 

1. 유저가 폴더를 생성하거나 파일을 업로드 한다.
2. 백엔드 서버와 통신하고 그 응답을 기다린다.
3. 응답에 맞게 브라우저에 아이콘을 표시한다.

위 흐름의 코드를 작성할 때 Target(폴더나 파일)의 상태는 로딩, 에러, 완료 3가지로 분류할 수 있고 코드로 표현하면 아래와 같다.

```typescript

const uploadFile(x) {
  if(x == loading){
    return 'loading';
  }
  if(x == error){
    return 'error';
  }
  if(x == success){
    return 'success';
  }
}
```
예시는 간단해 보이지만 위와 같은 비동기처리가 두개 겹친다면 상태는 3의 제곱인 9개가 된다.(x와 y 가 존재한다고 가정했을 때 두 개 모두 로딩, 에러, 완료의 상태가지므로 3*3=9) 그렇기 때문에 막연히 if 문으로만 해결하기에는 무리가 있었다.

이를 해결하고자 생각한 방법이 **'try-catch문'** 이다. 이 방법을 통해 성공, 실패의 경우를 분리해서 처리할 수 있었고, 코드의 로직을 한눈에 파악하기 쉽게 하였다.

실제 사용 예시

```typescript
//try-catch 구문
// 드라이브 관련코드는 좀 길어서 로그인으로 대체했습니다.
        try {
          const result = await instance.get('users/token/refresh');
          const accessToken = result.headers['access-token'];
          if (accessToken) sessionStorage.setItem('access-token', accessToken);
          navigate(0); // refresh
        } catch (err) {
          // refresh token 만료
          alert('다시 로그인 해주세요');
          store.dispatch(clearUser());
          navigate('/login');
        }


```
<br>

### 3. 기술부채 운용 방법
<br>

정해진 기간내에 요구사항을 만족시키는 코드를 짜야 했기 때문에 기능 구현에 집중해서 프로젝트를 진행했고 그에 따라 기술부채가 상당히 많이 쌓였다.

또한 기술부채가 쌓인 채로 다음 스프린트를 진행하게 된 적이 있었는데 스프린트가 끝난 후에는 또 다른 기술부채가 생겨서 이전에 발생했던 부채에 대해서는 잘 기억나지 않았다.

처음 기술부채가 생기고 있다는 것을 알았을 때는 이를 해결하고자 모르는 것을 바로바로 검색하고 학습하며 개발을 진행했지만 추후 이 방법이 바람직하지 않다는 것을 느꼈다.

기술부채 라는 것이 내가 사용한 기술에 대한 충분한 지식과 이해의 결핍에서부터 야기 되는데 바로바로 이를 해결하려고 하니 그저 문제의 해결 방법 만 찾은 후 지나가는 일이 잦았고 이는 근본적인 문제를 해결 할 수 없었다.

이후 기술부채 운용 방법에 대한 구체적인 계획을 세우게 됬다. 개발을 하며 확실히 알지 못했던 키워드를 정리해놓고 22시 이후와 주말에는 키워드 관련 학습을 진행했다. 또한 **'이와 비슷한 문제가 동료에게 발생한 다면 나는 이 문제의 원인과 해결방법에 대해 설명할 수 있는가?'**, 라는 학습의 기준을 세워 이를 달성하고자 노력했다.

### 4. TypeScript '잘' 쓰는 방법

<br>

| 이 고민은 아직 현재 진행형이긴 하지만 그래도 개인적으로 조금은 나아졌다고 생각한다.

'잘' 쓴다는 것은 무엇일까, 이것에 대해 많은 의견이 있을 수 있지만 '올바르게'와 '효율적'으로 사용한다면 잘쓴다의 기준에 부합 할 수 있을 것이다.

ts를 올바르게 혹은 효율적으로 사용하기 위해선 여러가지 방법이 있겠지만, 그 중 하나는 기술이 갖고 있는 철학을 이해하고 그에 맞게 사용하는 것이라고 생각한다.

이를 위해 나는 ts 공식문서를 자주 참고 했고 많은 도움을 얻을 수 있었다.

이러한 경험을 통해 얻은 내가 생각하는 ts **'잘'** 쓰는 방법은 다음과 같다.

1. interface를 남용하지 말자

- typemerging이 필요할 것으로 예상되거나 prop의 타입을 지정 하는 등 특정 상황이 아니라면 interface를 사용하는 것 보다는 type을 정의해서사용하는 것이 공식문서의 의도와 맞다.

2. any를 지양한다.

- any 타입은 어떠한 타입도 허용하는 타입으로 어떤 값이 할당될지 알 수 없을 때, 예를 들면 외부라이브러리로 부터 값을 가져올때 사용했었다. 하지만 타입 검사를 무조건 통과하는 any 타입을 남용하는 것은 typescript가 가져다주는 이점을 무효화 시킬 가능성이 높다.
- 이 경우 불가피한 경우를 제외 하고서는 any가 아닌 unknown 타입을 사용하는것이 더 나은 방법이 될 수 있다.
- unknown은 any 와 마찬가지로 모든 타입을 허용하지만 추후 연산될 때는 에러를 표출한다.

3. 남이 만든 타입 분석하기

-  프로젝트를 진행하며 React Component Types에 대해 알게 되었는데 이것과 마찬가지로 다른 라이브러리에서 제공하는 타입을 분석해보는것이 여러모로 도움이 됬다.



